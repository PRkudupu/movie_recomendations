Calculate moving average
city,store,product,no_items
how do you implement in hive
Hadoop version 1 and 2
submiting hive job . how it is doing in 1 version and 2 version
block size .How it would make it located

Arvind muruli perfecient

1) WHICH YEAR HAS THE MOST NO OF RATINGS
 
select year(from_unixtime(rating_time)) rating_year,count(*) as cnt
from latest_ratings 
group by year(from_unixtime(rating_time))
order by rating_year DESC

2) TOP RATED MOVIE IN EACH YEAR
This can be achieved by average ratings
average ratings = Sum of ratings / count (user ID)
 Note: 
	* Same user might have reviewed multiple times. This is the reason user should be distinct
	* Usually for one movie we would be asked to rate once
	* If everyone is getting average rating as 5.0 then we have a problem. It could be that particular
          movies would have been rated less. We might also get every rating as 5. we can have an having
	  condition where it would be greater than 500
        * we need to join with latest movies table to get the movie name
        * To get the top rated movie we would be using the ranking function where ranking =1

 select a.rating_year,
       b.title, 
       a.avg_rating 
      from (select movie_id , 
                   cast(sum(rating) as double)/count(distinct user_id) avg_rating , 
                   year(from_unixtime(rating_time)) rating_year, 
                   rank() over (partition by year(from_unixtime(rating_time)) 
                          order by cast(sum(rating) as double)/count(distinct user_id) desc) 
                    ranking from latest_ratings 
                    group by movie_id, year(from_unixtime(rating_time)) 
                    having count(distinct user_id) > 500 ) a 
      join latest_movies b 
      on a.movie_id = b.movie_id 
      where a.ranking = 1 
      order by a.rating_year

	1996    Schindler's List (1993) 4.514696276943174
	1997    Wallace & Gromit: The Wrong Trousers (1993)     4.5112903225806456
	1998    Saving Private Ryan (1998)      4.480701754385965
	1999    "Godfather      4.544752645124392
	2000    "Shawshank Redemption   4.553487376979033
	2001    "Shawshank Redemption   4.584341906202723
	2002    "Usual Suspects 4.589861751152074
	2003    "Shawshank Redemption   4.495418448381185
	2004    "Shawshank Redemption   4.3772394136807815
	2005    "Shawshank Redemption   4.3538953621201735
	2006    "Shawshank Redemption   4.390079103493737
	2007    "Shawshank Redemption   4.396220472440945
	2008    "Shawshank Redemption   4.435086810054418
	2009    "Shawshank Redemption   4.44210722263589
	2010    "Shawshank Redemption   4.432236376503893
	2011    "Shawshank Redemption   4.45922131147541
	2012    "Shawshank Redemption   4.408857509627728
	2013    "Shawshank Redemption   4.437730287398674
	2014    "Shawshank Redemption   4.3894086826347305
	2015    "Shawshank Redemption   4.392230338677545
	2016    "Shawshank Redemption   4.3361185383244205
	2017    Planet Earth (2006)     4.4364844903988185
	2018    "Shawshank Redemption   4.35815356065878
 
3) EVERY YEAR HAVING A MOVIE WHICH HAS MAX USERS
   * Every year for any movie id what is the max users (How many users has rated that movie in the particular year)
   * We need every year from 1
   * We would match the year rating with movie_id and max users with user count

create table tmp_movie_max_users_yearly 
as
select b.movie_id, 
       max(c.rating_year) myear, 
       b.max_users from 
         (select movie_id, 
          max(user_count) max_users 
          from ( select movie_id , year(from_unixtime(rating_time)) rating_year , 
                 count(distinct user_id) user_count 
                 from latest_ratings 
                 group by movie_id, year(from_unixtime(rating_time))) a 
           group by movie_id ) b 
join (select movie_id , 
             year(from_unixtime(rating_time)) rating_year , 
             count(distinct user_id) user_count 
             from latest_ratings group by movie_id, 
                  year(from_unixtime(rating_time))) c 
on b.movie_id = c.movie_id 
and b.max_users = c.user_count 
group by b.movie_id,b.max_users;


4) JOIN THE TABLE WHICH HAS MAX USERS EVERY YEAR FOR A MOVIE WITH TOP RATED MOVIES IN EACH YEAR
    
select c.rating_year,c.title, c.avg_rating 
	from (
		select a.movie_id 
		, cast(sum(a.rating) as double)/count(distinct a.user_id) avg_rating 
		, year(from_unixtime(a.rating_time)) rating_year
		, rank() over (partition by year(from_unixtime(rating_time)) 
		 	order by cast(sum(a.rating) as double)/count(distinct a.user_id) desc) ranking
		from latest_ratings a 
		group by movie_id, year(from_unixtime(rating_time))
		join  tmp_movie_max_users_yearly  b 
		  on a.movie_id=b.movie_id	
		  and year(from_unixtime(rating_time)) = b.myear
		group by a.movie_id,year(from_unixtime(a.rating_time))
	        having count(distinct user_id) > 100
	    ) c
	join latest_movies d
	on c.movie_id = d.movie_id
	where c.ranking = 1 
        order by c.rating_year
   


   5)WHICH MOVIE HAS BEEN RATED 50% MORE AFTER 5 YEARS FROM THIER RELEASE + NEXT YEAR
     * We need to have the release date
     * We need to have 5 years of movie data from thier release date

    SD -    2005 : 10000 - 4.2   - (10/12)=.83  (4.2 * .83) =3.4986
        
    Ikuri - 2005 : 6000  - 4.366 - (60/12) =.5  (4.366 * .50) =3.183

    *Our target is to have a movie release date 
     Which we need to get it from  
     Ex : Toy Story (1995)
          In this case it starts after the parenthesis and year is 4 character. so it would be 1995
          
     1) select substring(title, 12, 3)  from million_movies limit 10
     2) select instr(title'(') from million_movies limit 10  
        Note:This might not be the best solution as movie might have parenthesis
        Sol: We need to write a function to find parenthesis.Take the length of the string after
             If the length of the string is greater than 4 then we need to consider the second
             parenthesis
         Note:we also need to consider if there is a second bracket involved
         
     3) select distinct 
               case
                    when 
                    length(substring(title,instr(title,'(')+1,length(title))) > 5
                    then
                         substring(substring(title,instr(title,'(')+1,length(title)),'('+1,4)
                    else
                         substring(title,instr(title,'(')+1,length(title)),'('+1,4)
                    end    
                    from million_movies limit 10;
        
       4)select substring(title,instr(reverse(title),'(')) 
                 from million_movies limit 10;
       5)select substring(title,length(title) -instr(reverse(title), '('
                 from million_movies limit 10
       6) select substring(title,length(title) - instr(reverse(title),
          ,'('))+2,4) release_year 
                 from million_movies limit 10

        7)
	  create table latest_items as
		
		select distinct movie_id,title,
     		case
		when instr(reverse(title),'(') =0
		then ''
		when substring(title,instr((title), '('+1,4) between 1900 and 2020
                then substring(title,instr((title), '('+1,4)
		when substring(title,instr((title), '('+1,4) not between '1900' and '2020'
                then substring(title,instr((title), '('+1,4) and
                     substring(title, length(title)'('+1,4) - instr(reverse(title)), '('+2,4)
                     not between '1900' and '2020'
                then ' '
                else
                     substring(title, length(title)'('+1,4) - instr(reverse(title)), '('+2,4)
                end
                     release_year
                from latest_movies;
                else substring(title,length(title)

JOIN LATEST RATINGS AND LATEST ITEMS
  create table tmp_movies_rel_usrs AS
  select c.movie_id, max(c.user_counts) max_user_count
  from 
  (select movie_id,year(from_unixtime(rating_time)) rating_year,count(distinct user_id) user_counts
        from latest_ratings a
        join (select distinct movie_id,release_year,release_year+ 1 next_year
        from latest items
             where release_year > 1994) b
     on a.movie_id =b.movie_id 
	where year(from_unixtime(rating_time)) =b.release_year  or year(from_unixtime(rating_time)) =b.next_year
	group by a.movie_id,year(from_unixtime(a.rating_time))
        having user_counts > 500 ) c
        group by c.movie_id

 AFTER 5 YEARS
  create table tmp_movies_rel_later_usrs AS
  select c.movie_id, max(c.user_counts) max_user_count
  from 
  (select movie_id,year(from_unixtime(rating_time)) rating_year,count(distinct user_id) user_counts
        from latest_ratings a
        join (select distinct movie_id,release_year,release_year+ 5  after5years
        from latest items
             where release_year > 0) b
     on a.movie_id =b.movie_id 
	where year(from_unixtime(rating_time)) > =b.after5years
	group by a.movie_id,year(from_unixtime(a.rating_time))
        having user_counts > 500 ) c
        group by c.movie_id

MOVIE WHICH HAS BEEN RATED 50% MORE AFTER 5 YEARS FROM THE RELEASE
NOW WE NEED TO CALCULATE THE PERCENTAGE CHANGE FROM THE YEARS
    we NEED TO PULL OUT THE MAX CHANGES ANY YEAR
    WHEREVER WE FIND THE CHANGES GREATER THAN 100%
        select * from 
	(select a.movie_id,d.movie_title,c.rating_year,c.percentage_change,
        rank () over (partition by c.movie_id order by c.percentage_change desc) ranking
	(select a.movie_id,b.rating_year, cast(user_counts - max_user_count) * 100 percentage_change
                 as double)/max_user_count  
                 from tmp_movie_rel_users a
		 join tmp_movie_rel_later_users  b
         	 on a.movie_id = b.movie_id
		 where (cast((user_counts -max_user_count) as DOUBLE)/max_user_count) >=1) c
		 join latest_items d
                 on c.movie_id=d.movie_id
	) e
	 where e.ranking =1
         order by movie title limit 100

 6)OVER LAST 10 YEARS WHICH GENRE HAS SEEN MAXIMUM DECLINE IN MAKING MOVIES EACH YEAR

      select movie_id,title,genres 
	from latest_movies lateral view explode(split(genre, "\\| ")) asTable as generes where movie_id in (1,2) limit 10

       select genres as genre,count(distinct movie_id) mov 
	from latest_movies lateral view explode(split(genre, "\\| ")) asTable as generes where movie_id in (1,2) limit 10
	group by genres
	order by genres limit 10
        
	--This query would not work
        select genres as genre,count(distinct movie_id) mov 
	from latest_movies lateral view explode(split(genre, "\\| ")) asTable as generes where movie_id in (1,2) limit 10
	group by 1
	order by 1 limit 10
	--We need to set hive properties
	
	set hive.groupby.orderby.position.alias=true;





        


    
